import { ChatPromptTemplate, MessagesPlaceholder } from "@langchain/core/prompts";
import { RunnableSequence } from "@langchain/core/runnables";
import productModel from "../../../../models/Product.js";
import aiChatbotModel from "../../../../models/Chatbot.js";
import pool from "../../../../models/db.js";
import { extractSQL } from "../extra/parser.js";
import { loadSchema } from "../extra/schemaLoader.js";
import slugify from "slugify";
import { searchSimilar } from "../vectorStore.js";
import { encrypt } from "../extra/encrypt.js";
import { getVectorStore } from "../vectorStore.js";
import { model } from "../../../../controllers/api/Chatbot/llm.js";
import { pushLog } from "../extra/sseLogs.js";

function normalize(text) {
    return text.toLowerCase().replace(/[^a-z0-9]/g, "");
}

export const sql_generator = async ({ messages, email, session_id, history, intent }) => {
    console.log("üöß Executing: sql_generator");
    const logKey = email || session_id;

    const log = (msg, step = null) => pushLog(logKey, { msg, step });

    log(`Tr·ª£ l√≠ ƒëang truy c·∫≠p c∆° s·ªü d·ªØ li·ªáu.`, "sql-generator");

    try {
        const products = await productModel.getAll();

        const productList = products
            .map(p => `${p.name} (gi√° ${p.price}ƒë)`)
            .join(", ");

        // const formattedHistory = (history || [])
        //     .map(m => `${m.role === "user" ? "KH" : "AI"}: ${m.content}`)
        //     .join("\n");

        const sqlPromptTemplate = ChatPromptTemplate.fromMessages([
            ["system", `
B·∫°n l√† AI sinh c√¢u l·ªánh SQL t·ª´ c√¢u h·ªèi kh√°ch h√†ng v√† c√°c ch√≠nh s√°ch c·ªßa shop.

Y√™u c·∫ßu:
- Ch·ªâ sinh c√¢u l·ªánh SELECT ƒë√∫ng c√∫ ph√°p theo schema b√™n d∆∞·ªõi.
- KH√îNG ƒë∆∞·ª£c sinh UPDATE, DELETE, INSERT, DROP.
- N·∫øu truy v·∫•n t·ª´ b·∫£ng product th√¨ PH·∫¢I LU√îN bao g·ªìm c·ªôt \`id\`, \`discount_percentage\` v√† \`name\` trong SELECT (ƒë·ªÉ t·∫°o li√™n k·∫øt s·∫£n ph·∫©m).
- V√≠ d·ª•: h·ªèi gi√° th√¨ c·∫ßn SELECT id, name, price, discount_percentage.
- KH√îNG gi·∫£i th√≠ch. Tr·∫£ v·ªÅ SQL duy nh·∫•t b√™n trong block: \`\`\`sql ... \`\`\`

Khi h·ªèi v·ªÅ ƒë∆°n h√†ng th√¨ ph·∫£i l·∫•y th√™m lu√¥n email v√≠ d·ª•: th√¥ng tin ƒë∆°n h√†ng n√†y c·ªßa email ... l√† :...

--D·ªØ li·ªáu--
Schema: {schema}
danh s√°ch s·∫£n ph·∫©m - ƒë√¢y l√† s·∫£n ph·∫©m c·ªßa shop ƒëang b√°n(**D·ª±a v√†o ƒë√¢y ƒë·ªÉ s·ª≠a ch√≠nh t·∫£ kh√°ch h√†ng**): ${productList}
L·ªãch s·ª≠ t∆∞∆°ng t√°c kh√°ch h√†ng (trong db): {historyFormatted} 
`],
            ["human", `Email: {email}`],
            new MessagesPlaceholder("messages")
        ]);

        const userQuestion = messages.at(-1)?.content || "";

        console.log("‚úÖ intent in sql gen:", intent);

        const schema = await loadSchema();

        const encryptedMessage = encrypt(intent);
        const rawHistory = await aiChatbotModel.findByMessageAndEmail(encryptedMessage, email);

        const historyFormatted = rawHistory.map(row => {
            return `KH: ${row.question}\nAI: ${row.ai_answer}`;
        }).join("\n");

        const sqlChain = RunnableSequence.from([sqlPromptTemplate, model]);

        const response = await sqlChain.invoke({ messages, schema, email, historyFormatted });

        const sql = extractSQL(response.content);
        console.log("‚úÖ SQL:", sql);
        return { sql, current_step: "sql_executor" };
    } catch (error) {
        console.error("‚ùå sql_generator failed:", error.message);
        return {
            current_step: "__end__",
            error: "sql_generator failed: " + error.message,
        };
    };
}

export const sql_executor = async (state) => {
    console.log("üöß Executing: sql_executor");

    const lowerSQL = state.sql?.toLowerCase() || "";
    if (!lowerSQL.startsWith("select") || /update|delete|insert|drop/.test(lowerSQL)) {
        const warnMsg = {
            role: "ai",
            content: "‚ö†Ô∏è Bill ch·ªâ h·ªó tr·ª£ truy v·∫•n SELECT.",
        };
        return {
            messages: [...(state.messages || []), warnMsg],
            current_step: "__end__",
            error: "Non-SELECT SQL detected",
        };
    }

    const usesEmail = /\b[a-z_]*\.?email\b/.test(lowerSQL);

    if (usesEmail && !state.email) {
        const loginMsg = {
            role: "ai",
            content: "‚ö†Ô∏è B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ truy xu·∫•t th√¥ng tin c√° nh√¢n c·ªßa m√¨nh. Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi ti·∫øp t·ª•c.",
        };

        return {
            messages: [...(state.messages || []), loginMsg],
            current_step: "__end__",
            answered_intents: [...(state.answered_intents || []), "sql"],
        };
    }


    try {
        const [rows] = await pool.execute(state.sql);
        if (!rows.length) {
            console.warn("‚ö†Ô∏è Empty result");
            return {
                dbRows: rows,
                current_step: "__end__",
                error: "No rows returned",
            };
        }

        return { dbRows: rows, current_step: "result_refiner" };
    } catch (err) {
        console.error("‚ùå SQL execution error:", err.message);
        return {
            messages: [{ content: `‚ùå L·ªói SQL: ${err.message}` }],
            current_step: "__end__",
            error: "SQL execution failed",
        };
    }
};

export const result_refiner = async ({ messages, dbRows, session_id, history, intent, email }) => {
    console.log("üöß Executing: result_refiner");
    const logKey = email || session_id;
    const log = (msg, step = null) => pushLog(logKey, { msg, step });
    log(`Tr·ª£ l√≠ ƒë∆∞a ra c√¢u tr·∫£ l·ªùi.`, "sql-final-refiner");
    try {
        const allProducts = await productModel.getAll();
        await getVectorStore("sql_docs");
        const schema = await loadSchema();

        if (!dbRows || dbRows.length === 0) {
            return {
                refined: "‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ph√π h·ª£p.",
                resultMessage: "",
                messages: [{ content: "‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ph√π h·ª£p." }],
                current_step: "__end__"
            };
        }

        const headers = Object.keys(dbRows[0]).join(" | ");
        const rows = dbRows.map(r => Object.values(r).join(" | ")).join("\n");
        let raw = `‚úÖ K·∫øt qu·∫£:\n${headers}\n${rows}`;

        const urls = dbRows.filter(r => r.id && r.name).map(r => {
            const slug = slugify(r.name, { lower: true });
            return `[${r.name}](${process.env.FRONTEND_URL_NEXT}/san-pham/${slug}-${r.id})`;
        });

        if (urls.length > 0) raw += `\n${urls.join("\n")}`;

        const refinePrompt = ChatPromptTemplate.fromMessages([
            ["system", `
B·∫°n l√† tr·ª£ l√Ω AI c·∫ßu l√¥ng. D∆∞·ªõi ƒë√¢y l√† c√¢u h·ªèi c·ªßa kh√°ch h√†ng: {userQuestion} v√† d·ªØ li·ªáu th√¥ t·ª´ k·∫øt qu·∫£ SQL. H√£y di·ªÖn gi·∫£i l·∫°i th√¥ng tin m·ªôt c√°ch l·ªãch s·ª±, d·ªÖ hi·ªÉu v√† NG·∫ÆN G·ªåN cho kh√°ch h√†ng.

LU·∫¨T:
- N·∫øu d·ªØ li·ªáu l√† r·ªóng th√¨ tr·∫£ l·ªùi kh√¥ng c√≥ k·∫øt qu·∫£.
- N·∫øu trong d·ªØ li·ªáu c√≥ li√™n k·∫øt Markdown (d·∫°ng [T√™n](url)) th√¨ PH·∫¢I GI·ªÆ NGUY√äN.
- KH√îNG ƒë∆∞·ª£c t·ª± √Ω b·ªè li√™n k·∫øt, thay ƒë·ªïi URL, ho·∫∑c c·∫Øt b·ªè ph·∫ßn \"üì¶ Xem chi ti·∫øt\".

Schema:
{schema}

L·ªãch s·ª≠ giao ti·∫øp (·ªü database):
{formattedHistory}

D·ª±a v√†o l·ªãch s·ª≠ c·ªßa kh√°ch tr√™n ƒë√¢y ƒë·ªÉ h·ªçc v·ªÅ kh√°ch h√†ng, r√∫t kinh nghi·ªám sai l·∫ßm c·ªßa m√¨nh v√† sau khi tr·∫£ l·ªùi, n·∫øu ph√π h·ª£p, h√£y h·ªèi kh√°ch m·ªôt c√¢u ti·∫øp theo.

`],
            ["human", `{raw}`]
        ]);
        const userQuestion = messages.at(-1)?.content || "";

        const formattedHistory = (history || [])
            .map(m => `${m.role === "user" ? "KH" : "AI"}: ${m.content}`)
            .join("\n");

        const similar = await searchSimilar(userQuestion, 5, 0.5, "sql_docs");
        const context = similar.map(doc =>
            `KH: ${doc.pageContent}\nAI: ${doc.metadata.answer}`
        ).join("\n");

        const refineChain = RunnableSequence.from([refinePrompt, model]);
        const refined = await refineChain.invoke({ raw, schema, formattedHistory, userQuestion });

        const matched = [];
        const seen = new Set();
        const aiText = refined.content.toLowerCase();

        for (const p of allProducts) {
            if (
                aiText.includes(p.name.toLowerCase()) &&
                !seen.has(p.name)
            ) {
                matched.push(p);
                seen.add(p.name);
            }
        }

        let productDetailCards = "";
        if (matched.length > 0) {
            const urls = matched.map((p) => {
                const slug = slugify(p.name, { lower: true });
                const url = `${process.env.FRONTEND_URL_NEXT}/san-pham/${slug}-${p.id}`;
                const encodedMsg = encodeURIComponent(`t√¥i mu·ªën th√™m ${p.name} v√†o gi·ªè h√†ng`);
                const imgSrc = `${process.env.IMAGE_BASE_URL}/${p.featured_image}`;

                return `
<div class="product-card" 
     style="border: 1px solid #ccc; border-radius: 8px; 
            padding: 8px; margin-bottom: 8px; 
            display: flex; align-items: center; gap: 10px; 
            background: #f8f9fa; max-width: 400px;">

  <!-- Image -->
  <img src="${imgSrc}" alt="${p.name}" 
       style="width: 70px; height: 70px; object-fit: contain; border-radius: 6px;" />

  <!-- Info -->
  <div style="flex: 1; line-height: 1.3;">
    <a href="${url}" 
       style="font-weight: bold; font-size: 14px; color: #1D4ED8; display: block; margin-bottom: 4px;" 
       target="_blank">${p.name}</a>
    <span style="font-size: 13px; color: #16A34A;">üí∞ ${p.price.toLocaleString()}ƒë</span>
  </div>

  <!-- Small Button -->
  <button class="add-to-cart-btn" 
          data-product="${p.name}" data-msg="${encodedMsg}" 
          style="background: #FACC15; color: #000; border: none; 
                 padding: 4px 8px; border-radius: 4px; 
                 font-size: 12px; font-weight: 500; cursor: pointer;">
    üõí Th√™m
  </button>
</div>
`.trim();
            });

            productDetailCards = `\n${urls.join("\n")}`;
        }

        console.log("‚úÖ AI response");

        return {
            refined: refined.content + productDetailCards,
            resultMessage: raw,
            current_step: "responder"
        };
    } catch (error) {
        console.error("‚ùå result_refiner failed:", error.message);
        return {
            current_step: "__end__",
            error: "result_refiner failed: " + error.message,
        };
    }
};

export const responder = async ({ refined, messages, email, sql, dbRows, answered_intents = [], original_user_msg }) => {
    console.log("üöß Executing: responder");

    try {
        const safeAnswer = refined || "‚ùì Kh√¥ng c√≥ n·ªôi dung ph·∫£n h·ªìi.";

        return {
            messages: [...messages, { role: "ai", content: safeAnswer }],
            answered_intents: [...(answered_intents || []), "sql"],
            current_step: "__end__"
        };
    } catch (error) {
        console.error("‚ùå responder failed:", error.message);
        return {
            current_step: "__end__",
            error: "responder failed: " + error.message,
        };
    }
};

